{"version":3,"sources":["webpack:///src/views/workStudy/vuex/core/mutation/index.vue","webpack:///./src/views/workStudy/vuex/core/mutation/index.vue?89c0","webpack:///./src/views/workStudy/vuex/core/mutation/index.vue"],"names":["mutation","count","core_mutation","render","this","$createElement","_self","_c","_m","staticRenderFns","_vm","_h","staticClass","_v","Component","__webpack_require__","normalizeComponent","__webpack_exports__"],"mappings":"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","file":"static/js/10.b8c536dda45a5c26ad23.js","sourcesContent":["<template>\n  <div class=\"v-vuex-core-mutation\">\n    <p class=\"v-txt\">\n      更改Vuex的store中的状态的唯一方法是提交mutation。vuex中的mutation非常类似于事件：每个mutation都有一个字符串的<b>事件类型（type）</b>和一个<b>回调函数（handler）</b>。这个回调函数就是我们实际进行状态更改的地方，并且它会接受state作为第一个参数。\n    </p>\n    <pre class=\"line-numbers\">\n      <code class=\"language-js\">\n        const store = new Vuex.Store({\n          state: {\n            count: 0,\n          },\n          mutations: {\n            increment(state) {\n              state.count++\n            }\n          }\n        })\n      </code>\n    </pre>\n    <p class=\"v-txt\">\n      你不能直接调用mutation handler。这个选项更像是事件注册：“当触发一个类型为increment的mutation时，调用此函数。”要唤醒一个handler，我们需要以相应的type调用store.commit方法：\n    </p>\n    <pre class=\"line-numbers\">\n      <code class=\"language-js\">\n        this.$store.commit('increment')\n      </code>\n    </pre>\n    <p class=\"v-note\">\n      提交载荷（Payload）——传参\n    </p>\n    <pre class=\"line-numbers\">\n      <code class=\"language-js\">\n        const store = new Vuex.Store({\n          state: {\n            count: 0,\n          },\n          mutations: {\n            increment(state, n) {\n              state.count += n;\n            }\n          }\n        })\n      </code>\n    </pre>\n    <pre class=\"line-numbers\">\n      <code class=\"language-js\">\n        this.$store.commit('increment', 10);\n      </code>\n    </pre>\n    <p class=\"v-txt\">\n      （大多数情况下，参数应该是一个对象，这样会包含多个字段，并且记录的mutation会更易读。）\n    </p>\n    <p class=\"v-note\">\n      对象风格的提交方式\n    </p>\n    <pre class=\"line-numbers\">\n      <code class=\"language-js\">\n        const store = new Vuex.Store({\n          state: {\n            count: 0,\n          },\n          mutations: {\n            increment(state, obj) {\n              state.count += obj.num;\n            }\n          }\n        })\n      </code>\n    </pre>\n    <pre class=\"line-numbers\">\n      <code class=\"language-js\">\n        this.$store.commit({ type: 'increment', num: 2 });\n      </code>\n    </pre>\n    <p class=\"v-note\">\n      mutation必须是同步函数\n    </p>\n    <pre class=\"line-numbers\">\n      <code class=\"language-js\">\n        mutations: {\n          someMutation (state) {\n            api.callAsyncMethod(() => {\n              state.count++\n            })\n          }\n        }\n      </code>\n    </pre>\n    <p class=\"v-txt\">\n      现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。\n    </p>\n    <p class=\"v-note\">\n      在组件中提交mutation\n    </p>\n    <p class=\"v-title\">一、</p>\n    <p class=\"v-txt\">\n      使用this.$store.commit('xxx') 提交 mutation\n    </p>\n    <p class=\"v-title\">二、</p>\n    <p class=\"v-txt\">\n      使用mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。\n    </p>\n    <pre class=\"line-numbers\">\n      <code class=\"language-js\">\n        import { mapMutations } from 'vuex'\n\n        export default {\n          // ...\n          methods: {\n            ...mapMutations([\n              'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\n\n              // `mapMutations` 也支持载荷：\n              'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`\n            ]),\n            ...mapMutations({\n              add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`\n            })\n          }\n        }\n      </code>\n    </pre>\n  </div>\n</template>\n\n<script>\n  import mixin from '@/mixins/prism';\n  export default {\n    name: 'vuex-core-mutation',\n    mixins: [mixin],\n    methods: {\n      testmutation() {\n        this.$store.commit({ type: 'increment', num: 2 });\n        console.log(this.$store.state.count);\n      }\n    }\n  }\n</script>\n\n\n\n// WEBPACK FOOTER //\n// src/views/workStudy/vuex/core/mutation/index.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"v-vuex-core-mutation\"},[_c('p',{staticClass:\"v-txt\"},[_vm._v(\"\\n    更改Vuex的store中的状态的唯一方法是提交mutation。vuex中的mutation非常类似于事件：每个mutation都有一个字符串的\"),_c('b',[_vm._v(\"事件类型（type）\")]),_vm._v(\"和一个\"),_c('b',[_vm._v(\"回调函数（handler）\")]),_vm._v(\"。这个回调函数就是我们实际进行状态更改的地方，并且它会接受state作为第一个参数。\\n  \")]),_vm._v(\" \"),_c('pre',{staticClass:\"line-numbers\"},[_vm._v(\"    \"),_c('code',{staticClass:\"language-js\"},[_vm._v(\"\\n      const store = new Vuex.Store({\\n        state: {\\n          count: 0,\\n        },\\n        mutations: {\\n          increment(state) {\\n            state.count++\\n          }\\n        }\\n      })\\n    \")]),_vm._v(\"\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-txt\"},[_vm._v(\"\\n    你不能直接调用mutation handler。这个选项更像是事件注册：“当触发一个类型为increment的mutation时，调用此函数。”要唤醒一个handler，我们需要以相应的type调用store.commit方法：\\n  \")]),_vm._v(\" \"),_c('pre',{staticClass:\"line-numbers\"},[_vm._v(\"    \"),_c('code',{staticClass:\"language-js\"},[_vm._v(\"\\n      this.$store.commit('increment')\\n    \")]),_vm._v(\"\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-note\"},[_vm._v(\"\\n    提交载荷（Payload）——传参\\n  \")]),_vm._v(\" \"),_c('pre',{staticClass:\"line-numbers\"},[_vm._v(\"    \"),_c('code',{staticClass:\"language-js\"},[_vm._v(\"\\n      const store = new Vuex.Store({\\n        state: {\\n          count: 0,\\n        },\\n        mutations: {\\n          increment(state, n) {\\n            state.count += n;\\n          }\\n        }\\n      })\\n    \")]),_vm._v(\"\\n  \")]),_vm._v(\" \"),_c('pre',{staticClass:\"line-numbers\"},[_vm._v(\"    \"),_c('code',{staticClass:\"language-js\"},[_vm._v(\"\\n      this.$store.commit('increment', 10);\\n    \")]),_vm._v(\"\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-txt\"},[_vm._v(\"\\n    （大多数情况下，参数应该是一个对象，这样会包含多个字段，并且记录的mutation会更易读。）\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-note\"},[_vm._v(\"\\n    对象风格的提交方式\\n  \")]),_vm._v(\" \"),_c('pre',{staticClass:\"line-numbers\"},[_vm._v(\"    \"),_c('code',{staticClass:\"language-js\"},[_vm._v(\"\\n      const store = new Vuex.Store({\\n        state: {\\n          count: 0,\\n        },\\n        mutations: {\\n          increment(state, obj) {\\n            state.count += obj.num;\\n          }\\n        }\\n      })\\n    \")]),_vm._v(\"\\n  \")]),_vm._v(\" \"),_c('pre',{staticClass:\"line-numbers\"},[_vm._v(\"    \"),_c('code',{staticClass:\"language-js\"},[_vm._v(\"\\n      this.$store.commit({ type: 'increment', num: 2 });\\n    \")]),_vm._v(\"\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-note\"},[_vm._v(\"\\n    mutation必须是同步函数\\n  \")]),_vm._v(\" \"),_c('pre',{staticClass:\"line-numbers\"},[_vm._v(\"    \"),_c('code',{staticClass:\"language-js\"},[_vm._v(\"\\n      mutations: {\\n        someMutation (state) {\\n          api.callAsyncMethod(() => {\\n            state.count++\\n          })\\n        }\\n      }\\n    \")]),_vm._v(\"\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-txt\"},[_vm._v(\"\\n    现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-note\"},[_vm._v(\"\\n    在组件中提交mutation\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-title\"},[_vm._v(\"一、\")]),_vm._v(\" \"),_c('p',{staticClass:\"v-txt\"},[_vm._v(\"\\n    使用this.$store.commit('xxx') 提交 mutation\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-title\"},[_vm._v(\"二、\")]),_vm._v(\" \"),_c('p',{staticClass:\"v-txt\"},[_vm._v(\"\\n    使用mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。\\n  \")]),_vm._v(\" \"),_c('pre',{staticClass:\"line-numbers\"},[_vm._v(\"    \"),_c('code',{staticClass:\"language-js\"},[_vm._v(\"\\n      import { mapMutations } from 'vuex'\\n\\n      export default {\\n        // ...\\n        methods: {\\n          ...mapMutations([\\n            'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\\n\\n            // `mapMutations` 也支持载荷：\\n            'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`\\n          ]),\\n          ...mapMutations({\\n            add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`\\n          })\\n        }\\n      }\\n    \")]),_vm._v(\"\\n  \")])])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-2de97528\",\"hasScoped\":false,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/views/workStudy/vuex/core/mutation/index.vue\n// module id = null\n// module chunks = ","var normalizeComponent = require(\"!../../../../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../../../../node_modules/vue-loader/lib/selector?type=script&index=0!./index.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../../../../node_modules/vue-loader/lib/selector?type=script&index=0!./index.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-2de97528\\\",\\\"hasScoped\\\":false,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../../../../node_modules/vue-loader/lib/selector?type=template&index=0!./index.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = null\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/workStudy/vuex/core/mutation/index.vue\n// module id = null\n// module chunks = "],"sourceRoot":""}