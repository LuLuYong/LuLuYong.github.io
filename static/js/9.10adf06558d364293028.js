webpackJsonp([9],{C37y:function(t,n,s){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var e=s("Dd8w"),a=s.n(e),c=s("SZs6"),o=s("NYxO"),u={name:"vuex-core-state",mixins:[c.a],computed:a()({otherComputed:function(){return this.localCount}},Object(o.b)(["count"])),data:function(){return{localCount:2}},methods:{addCount:function(){console.log(this.status)}}},v={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var t=this,n=t.$createElement,s=t._self._c||n;return s("div",{staticClass:"v-vuex-core-state"},[s("p",{staticClass:"v-note"},[t._v("单一状态树")]),t._v(" "),s("p",{staticClass:"v-txt"},[t._v("\n    单一状态树即用一个对象就包含了全部的应用层级状态。所以，这个对象就作为整个应用里唯一的数据源而存在。其意义就是每个应用实例仅有一个store实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。"),s("b",[t._v("单状态树和模块化并不冲突。")])]),t._v(" "),s("p",{staticClass:"v-note"},[t._v("\n    获得vuex状态\n  ")]),t._v(" "),s("p",{staticClass:"v-title"},[t._v("\n    在vue-cli项目中，我们可以通过如下方式将vuex状态从根组件注入到每一个子组件中（通过vue的store选项），这样子组件就能通过this.$store来访问到store状态。代码如下：\n  ")]),t._v(" "),s("pre",{staticClass:"line-numbers"},[t._v("    "),s("code",{staticClass:"language-js"},[t._v("\n      // 在上一节，已经在src目录下新建了store文件夹以及store文件夹下的一个js文件，js文件先命名为index.js文件，其内容如下\n      import Vue from 'vue'\n      import Vuex from 'vuex'\n      Vue.use(Vuex)\n      const store = new Vuex.Store({\n        state: {\n          count: 0\n        },\n        mutations: {\n          increment(state) {\n            state.count++\n          }\n        }\n      })\n      export default store\n    ")]),t._v("\n  ")]),t._v(" "),s("p",{staticClass:"v-txt"},[t._v("\n    访问store状态代码如下：\n  ")]),t._v(" "),s("pre",{staticClass:"line-numbers"},[t._v("    "),s("code",{staticClass:"language-js"},[t._v("\n      created() {\n        console.log(this.$store.count) // => 0\n      }\n    ")]),t._v("\n  ")]),t._v(" "),s("p",{staticClass:"v-title"},[t._v("\n    如果每次从vuex中取状态都以this.$store的方式取的话，无疑是很麻烦的。因为vuex的状态存储是响应式的，所以从stroe中读取状态最简单的方法就是在计算属性中返回某个状态\n  ")]),t._v(" "),s("pre",{staticClass:"line-numbers"},[t._v("    "),s("code",{staticClass:"language-js"},[t._v("\n      computed: {\n        count() {\n          return this.store.state.count;\n        }\n      }\n    ")]),t._v("\n  ")]),t._v(" "),s("p",{staticClass:"v-note"},[t._v("辅助函数mapState")]),t._v(" "),s("p",{staticClass:"v-title"},[t._v("\n    但是当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用mapState辅助函数帮助我们生成计算属性：\n  ")]),t._v(" "),s("pre",{staticClass:"line-numbers"},[t._v("    "),s("code",{staticClass:"language-js"},[t._v("\n      computed: mapState({\n        count: state => state.count,\n        countAlias: 'count',\n        countPlusLocalState(state) {\n          return state.count + this.localCount;\n        }\n      }),\n      data() {\n        return {\n          localCount: 2\n        }\n      }\n    ")]),t._v("\n  ")]),t._v(" "),s("p",{staticClass:"v-txt"},[t._v("\n    从上面代码我们可以看到，计算属性等于mapState函数，而mapState函数接受一个Object为参数，而这个参数里有三个属性，现在来分析这三个属性：\n  ")]),t._v(" "),s("p",{staticClass:"v-txt"},[t._v("\n    a> count: state => state.count\n  ")]),t._v(" "),s("pre",{staticClass:"line-numbers"},[t._v("    "),s("code",{staticClass:"language-js"},[t._v("\n      computed: mapState({\n        count: state => state.count\n      })\n    ")]),t._v("\n  ")]),t._v(" "),s("p",{staticClass:"v-txt"},[t._v("\n    其实，上面的代码等于下面的代码，箭头函数是为了代码的整洁性。\n  ")]),t._v(" "),s("pre",{staticClass:"line-numbers"},[t._v("    "),s("code",{staticClass:"language-js"},[t._v("\n      compute: {\n        count() {\n          return this.$store.state.count;\n        }\n      }\n    ")]),t._v("\n  ")]),t._v(" "),s("p",{staticClass:"v-txt"},[t._v("\n    b> countAlias: 'count'\n  ")]),t._v(" "),s("p",{staticClass:"v-txt"},[t._v("\n    这个属性和上面count的箭头函数属性是等价的，countAlias的值是state的一个状态属性（此时，取的是count）。所以，count和countAlias这两个属性只需要一个就可以了。\n  ")]),t._v(" "),s("p",{staticClass:"v-txt"},[t._v("\n    c> countPlusLocalState(state) { return state.count + this.localCount; }\n  ")]),t._v(" "),s("p",{staticClass:"v-txt"},[t._v("\n    至于第三条属性其实和上面两条属性也是一样的，只不过是采取了常规函数的写法，而不是箭头函数，是因为countPlusLocalState这个计算属性还要取data里面return出来的localCount值，所以必须用到this，所以只能采取常规函数写法而不是箭头函数。\n  ")]),t._v(" "),s("p",{staticClass:"v-note"},[t._v("注意")]),t._v(" "),s("p",{staticClass:"v-title"},[t._v("当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。")]),t._v(" "),s("pre",{staticClass:"line-numbers"},[t._v("    "),s("code",{staticClass:"language-js"},[t._v("\n      computed: mapState([\n        'status'\n      ])\n    ")]),t._v("\n  ")]),t._v(" "),s("p",{staticClass:"v-note"},[t._v("\n    对象展开运算符\n  ")]),t._v(" "),s("p",{staticClass:"v-txt"},[t._v("\n    我们知道，计算属性是一个对象，而mapState返回的也是一个对象，上面的代码其实是让计算属性等于mapState返回的对象。所以，我们如何将mapState辅助函数与其它计算属性混合使用。这时就用到了对象展开运算符：\n  ")]),t._v(" "),s("pre",{staticClass:"line-numbers"},[t._v("    "),s("code",{staticClass:"language-js"},[t._v("\n      computed: {\n        otherComputed() {\n          return this.localCount;\n        },\n        ...mapState([\n          'count'\n        ])\n      },\n      data() {\n        return {\n          localCount: 2\n        }\n      }\n    ")]),t._v("\n  ")])])}]},l=s("VU/8")(u,v,!1,null,null,null);n.default=l.exports}});
//# sourceMappingURL=9.10adf06558d364293028.js.map