{"version":3,"sources":["webpack:///src/views/workStudy/vuex/core/action/index.vue","webpack:///./src/views/workStudy/vuex/core/action/index.vue?4fc6","webpack:///./src/views/workStudy/vuex/core/action/index.vue"],"names":["action","core_action","render","this","$createElement","_self","_c","_m","staticRenderFns","_vm","_h","staticClass","_v","Component","__webpack_require__","normalizeComponent","__webpack_exports__"],"mappings":"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","file":"static/js/16.c31550da3b95af708587.js","sourcesContent":["<template>\n  <div class=\"v-vuex-core-action\">\n    <p class=\"v-title\">\n      action类似于mutation，不同之处在于：\n    </p>\n    <ul class=\"v-lists\">\n      <li class=\"v-list\">Action提交的是mutation，而不是直接变更状态</li>\n      <li class=\"v-list\">action可以包含任意异步操作</li>\n    </ul>\n    <pre class=\"line-numbers\">\n      <code class=\"language-js\">\n        const store = new Vuex.Store({\n          state: {\n            count: 14,\n          mutations: {\n            increment(state) {\n              state.count++\n            }\n          },\n          actions: {\n            increment (context) {\n              context.commit('increment')\n            }\n          }\n        })\n      </code>\n    </pre>\n    <p class=\"v-txt\">\n      Action函数接受一个与store实例具有相同属性和方法的context对象，因此，我们可以调用context.commit提交一个mutation，或者通过context.state和context.getters来获取state和getter\n    </p>\n    <p class=\"v-txt\">\n      <b>注意：</b>context对象不是store实例本身\n    </p>\n    <p class=\"v-txt\">\n      实践中，我们经常使用es6的参数解构来简化代码\n    </p>\n    <pre class=\"line-numbers\">\n      <code class=\"language-js\">\n        actions: {\n          increment ({ commit }) {\n            commit('increment')\n          }\n        }\n      </code>\n    </pre>\n    <p class=\"v-note\">\n      分发Action\n    </p>\n    <pre class=\"line-numbers\">\n      <code class=\"language-js\">\n        this.$store.dispatch('increment');\n      </code>\n    </pre>\n    <p class=\"v-txt\">\n      action支持同样的载荷方式和对象方式进行分发\n    </p>\n    <pre class=\"line-numbers\">\n      <code class=\"language-js\">\n        // 以载荷形式分发\n        store.dispatch('incrementAsync', {\n          amount: 10\n        })\n\n        // 以对象形式分发\n        store.dispatch({\n          type: 'incrementAsync',\n          amount: 10\n        })\n      </code>\n    </pre>\n    <p class=\"v-note\">\n      在组件中分发action\n    </p>\n    <ul class=\"v-lists\">\n      <li class=\"v-list\">一、使用 this.$store.dispatch('xxx') 分发 action。</li>\n      <li class=\"v-list\">二、使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）。</li>\n    </ul>\n    <p class=\"v-note\">\n      组合Action\n    </p>\n    <p class=\"v-txt\">\n      Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？\n    </p>\n    <p class=\"v-txt\">\n      <b>首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise：</b>\n    </p>\n    <pre class=\"line-numbers\">\n      <code class=\"language-js\">\n        actions: {\n          actionA ({ commit }) {\n            return new Promise((resolve, reject) => {\n              setTimeout(() => {\n                commit('someMutation')\n                resolve()\n              }, 1000)\n            })\n          }\n        }\n      </code>\n    </pre>\n    <p class=\"v-txt\">\n      现在，我们可以这样做\n    </p>\n    <pre class=\"line-numbers\">\n      <code class=\"language-js\">\n        this.$store.dispatch('actionA').then(() => {\n          // ...\n        })\n      </code>\n    </pre>\n    <p class=\"v-txt\">\n      在另外一个action中也可以这样做\n    </p>\n    <pre class=\"line-numbers\">\n      <code class=\"language-js\">\n        actions: {\n          // ...\n          actionB ({ dispatch, commit }) {\n            return dispatch('actionA').then(() => {\n              commit('someOtherMutation')\n            })\n          }\n        }\n      </code>\n    </pre>\n    <p class=\"v-txt\">\n      最后，如果我们利用 async / await，我们可以如下组合 action：\n    </p>\n    <pre class=\"line-numbers\">\n      <code class=\"language-js\">\n        // 假设 getData() 和 getOtherData() 返回的是 Promise\n        actions: {\n          async actionA ({ commit }) {\n            commit('gotData', await getData())\n          },\n          async actionB ({ dispatch, commit }) {\n            await dispatch('actionA') // 等待 actionA 完成\n            commit('gotOtherData', await getOtherData())\n          }\n        }\n      </code>\n    </pre>\n    <p class=\"v-title\">\n      一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。\n    </p>\n  </div>\n</template>\n\n<script>\n  import mixin from '@/mixins/prism';\n  export default {\n    name: 'vuex-core-action',\n    mixins: [mixin]\n  }\n</script>\n\n\n\n// WEBPACK FOOTER //\n// src/views/workStudy/vuex/core/action/index.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"v-vuex-core-action\"},[_c('p',{staticClass:\"v-title\"},[_vm._v(\"\\n    action类似于mutation，不同之处在于：\\n  \")]),_vm._v(\" \"),_c('ul',{staticClass:\"v-lists\"},[_c('li',{staticClass:\"v-list\"},[_vm._v(\"Action提交的是mutation，而不是直接变更状态\")]),_vm._v(\" \"),_c('li',{staticClass:\"v-list\"},[_vm._v(\"action可以包含任意异步操作\")])]),_vm._v(\" \"),_c('pre',{staticClass:\"line-numbers\"},[_vm._v(\"    \"),_c('code',{staticClass:\"language-js\"},[_vm._v(\"\\n      const store = new Vuex.Store({\\n        state: {\\n          count: 14,\\n        mutations: {\\n          increment(state) {\\n            state.count++\\n          }\\n        },\\n        actions: {\\n          increment (context) {\\n            context.commit('increment')\\n          }\\n        }\\n      })\\n    \")]),_vm._v(\"\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-txt\"},[_vm._v(\"\\n    Action函数接受一个与store实例具有相同属性和方法的context对象，因此，我们可以调用context.commit提交一个mutation，或者通过context.state和context.getters来获取state和getter\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-txt\"},[_c('b',[_vm._v(\"注意：\")]),_vm._v(\"context对象不是store实例本身\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-txt\"},[_vm._v(\"\\n    实践中，我们经常使用es6的参数解构来简化代码\\n  \")]),_vm._v(\" \"),_c('pre',{staticClass:\"line-numbers\"},[_vm._v(\"    \"),_c('code',{staticClass:\"language-js\"},[_vm._v(\"\\n      actions: {\\n        increment ({ commit }) {\\n          commit('increment')\\n        }\\n      }\\n    \")]),_vm._v(\"\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-note\"},[_vm._v(\"\\n    分发Action\\n  \")]),_vm._v(\" \"),_c('pre',{staticClass:\"line-numbers\"},[_vm._v(\"    \"),_c('code',{staticClass:\"language-js\"},[_vm._v(\"\\n      this.$store.dispatch('increment');\\n    \")]),_vm._v(\"\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-txt\"},[_vm._v(\"\\n    action支持同样的载荷方式和对象方式进行分发\\n  \")]),_vm._v(\" \"),_c('pre',{staticClass:\"line-numbers\"},[_vm._v(\"    \"),_c('code',{staticClass:\"language-js\"},[_vm._v(\"\\n      // 以载荷形式分发\\n      store.dispatch('incrementAsync', {\\n        amount: 10\\n      })\\n\\n      // 以对象形式分发\\n      store.dispatch({\\n        type: 'incrementAsync',\\n        amount: 10\\n      })\\n    \")]),_vm._v(\"\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-note\"},[_vm._v(\"\\n    在组件中分发action\\n  \")]),_vm._v(\" \"),_c('ul',{staticClass:\"v-lists\"},[_c('li',{staticClass:\"v-list\"},[_vm._v(\"一、使用 this.$store.dispatch('xxx') 分发 action。\")]),_vm._v(\" \"),_c('li',{staticClass:\"v-list\"},[_vm._v(\"二、使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）。\")])]),_vm._v(\" \"),_c('p',{staticClass:\"v-note\"},[_vm._v(\"\\n    组合Action\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-txt\"},[_vm._v(\"\\n    Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-txt\"},[_c('b',[_vm._v(\"首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise：\")])]),_vm._v(\" \"),_c('pre',{staticClass:\"line-numbers\"},[_vm._v(\"    \"),_c('code',{staticClass:\"language-js\"},[_vm._v(\"\\n      actions: {\\n        actionA ({ commit }) {\\n          return new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n              commit('someMutation')\\n              resolve()\\n            }, 1000)\\n          })\\n        }\\n      }\\n    \")]),_vm._v(\"\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-txt\"},[_vm._v(\"\\n    现在，我们可以这样做\\n  \")]),_vm._v(\" \"),_c('pre',{staticClass:\"line-numbers\"},[_vm._v(\"    \"),_c('code',{staticClass:\"language-js\"},[_vm._v(\"\\n      this.$store.dispatch('actionA').then(() => {\\n        // ...\\n      })\\n    \")]),_vm._v(\"\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-txt\"},[_vm._v(\"\\n    在另外一个action中也可以这样做\\n  \")]),_vm._v(\" \"),_c('pre',{staticClass:\"line-numbers\"},[_vm._v(\"    \"),_c('code',{staticClass:\"language-js\"},[_vm._v(\"\\n      actions: {\\n        // ...\\n        actionB ({ dispatch, commit }) {\\n          return dispatch('actionA').then(() => {\\n            commit('someOtherMutation')\\n          })\\n        }\\n      }\\n    \")]),_vm._v(\"\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-txt\"},[_vm._v(\"\\n    最后，如果我们利用 async / await，我们可以如下组合 action：\\n  \")]),_vm._v(\" \"),_c('pre',{staticClass:\"line-numbers\"},[_vm._v(\"    \"),_c('code',{staticClass:\"language-js\"},[_vm._v(\"\\n      // 假设 getData() 和 getOtherData() 返回的是 Promise\\n      actions: {\\n        async actionA ({ commit }) {\\n          commit('gotData', await getData())\\n        },\\n        async actionB ({ dispatch, commit }) {\\n          await dispatch('actionA') // 等待 actionA 完成\\n          commit('gotOtherData', await getOtherData())\\n        }\\n      }\\n    \")]),_vm._v(\"\\n  \")]),_vm._v(\" \"),_c('p',{staticClass:\"v-title\"},[_vm._v(\"\\n    一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。\\n  \")])])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-ea95a182\",\"hasScoped\":false,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/views/workStudy/vuex/core/action/index.vue\n// module id = null\n// module chunks = ","var normalizeComponent = require(\"!../../../../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../../../../node_modules/vue-loader/lib/selector?type=script&index=0!./index.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../../../../node_modules/vue-loader/lib/selector?type=script&index=0!./index.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-ea95a182\\\",\\\"hasScoped\\\":false,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../../../../node_modules/vue-loader/lib/selector?type=template&index=0!./index.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = null\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/workStudy/vuex/core/action/index.vue\n// module id = null\n// module chunks = "],"sourceRoot":""}